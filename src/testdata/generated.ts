// Auto generated by "./scripts/ignore_config_gen.sh". DO NOT EDIT.
import { z } from "zod";

// cf. https://document.microcms.io/manual/automatic-grant-fields
export const MicroCmsObjectContentFieldsSchema = z.object({
  createdAt: z.string().datetime(),
  updatedAt: z.string().datetime(),
  publishedAt: z.string().datetime().optional(),
  revisedAt: z.string().datetime().optional(),
});
export type MicroCmsObjectContentFields = z.infer<
  typeof MicroCmsObjectContentFieldsSchema
>;

export const OnlyIdSchema = z.object({
  id: z.string(),
});
export type OnlyId = z.infer<typeof OnlyIdSchema>;

export const MicroCmsListContentFieldsSchema =
  MicroCmsObjectContentFieldsSchema.merge(OnlyIdSchema);
export type MicroCmsListContentFields = z.infer<
  typeof MicroCmsListContentFieldsSchema
>;

export const makeListResponseSchema = <ContentSchema extends z.AnyZodObject>(
  contentSchema: ContentSchema,
) =>
  z.object({
    contents: z.array(MicroCmsListContentFieldsSchema.merge(contentSchema)),
    totalCount: z.number(),
    limit: z.number(),
    offset: z.number(),
  });
export type ListResponse = z.infer<ReturnType<typeof makeListResponseSchema>>;

export const ObjectContentMetadataSchema = z.object({
  createdAt: z.string().datetime(),
  updatedAt: z.string().datetime(),
  publishedAt: z.string().datetime().nullable(),
  revisedAt: z.string().datetime().nullable(),
  closedAt: z.string().datetime().nullable(),
  status: z.tuple([
    z.enum(["DRAFT", "PUBLISH", "PUBLISH_AND_DRAFT", "CLOSED"]),
  ]),
  customStatus: z.tuple([z.unknown()]).nullable(),
  draftKey: z.string().nullable(),
  reservationTime: z
    .object({
      publishTime: z.string().datetime().nullable(),
      stopTime: z.string().datetime().nullable(),
    })
    .nullable(),
});
export type ObjectContentMetadata = z.infer<typeof ObjectContentMetadataSchema>;

export const ListContentMetadataSchema = ObjectContentMetadataSchema.extend({
  id: z.string(),
});
export type ListContentMetadata = z.infer<typeof ListContentMetadataSchema>;

export const SampleForListApiSchema = z.object({
  textfield: z.string().optional(),
});
export type SampleForListApi = z.infer<typeof SampleForListApiSchema>;

// eslint-disable-next-line @typescript-eslint/naming-convention
export const SampleForObjectApi_CustomField1Schema = z.object({
  fieldId: z.string(),
  title: z.string().optional(),
});
// eslint-disable-next-line @typescript-eslint/naming-convention
export type SampleForObjectApi_CustomField1 = z.infer<
  typeof SampleForObjectApi_CustomField1Schema
>;

export const SampleForObjectApiSchema = z.object({
  textfield: z.string().optional(),
  textarea: z.string().optional(),
  richeditor: z.string().optional(),
  image: z
    .object({
      url: z.string().url(),
      height: z.number(),
      width: z.number(),
    })
    .optional(),
  multipleimage: z
    .array(
      z.object({
        url: z.string().url(),
        height: z.number(),
        width: z.number(),
      }),
    )
    .optional(),
  datetime: z.string().datetime().optional(),
  boolean: z.boolean().optional(),
  selectfield: z.tuple([z.enum(["option1", "option2"])]).optional(),
  multipleselectfield: z.array(z.enum(["option1", "option2"])).optional(),
  number: z.number().optional(),
  relation: OnlyIdSchema.and(z.unknown()).optional(),
  multirelation: z.array(OnlyIdSchema.and(z.unknown())).optional(),
  customField: SampleForObjectApi_CustomField1Schema.optional(),
  repeater: z.array(SampleForObjectApi_CustomField1Schema).optional(),
});
export type SampleForObjectApi = z.infer<typeof SampleForObjectApiSchema>;

export const SampleForListApiInputSchema = SampleForListApiSchema.omit(
  {},
).extend({});
export type SampleForListApiInput = z.infer<typeof SampleForListApiInputSchema>;

export const SampleForObjectApiInputSchema = SampleForObjectApiSchema.omit({
  multipleimage: true,
  relation: true,
  multirelation: true,
}).extend({
  relation: z.string(),
  multirelation: z.array(z.string()),
});
export type SampleForObjectApiInput = z.infer<
  typeof SampleForObjectApiInputSchema
>;

export type RequestOptions = RequestInit & {
  customFetcher?: typeof fetch;
};

export type QueryForObjectApi = {
  draftKey?: string;
  fields?: string[];
  depth?: 1 | 2 | 3;
};

export type QueryForListApi = QueryForObjectApi & {
  limit: number;
  offset?: number;
  orders?: string[];
  q?: string;
  ids?: string[];
  filters?: string;
};

export class RequestError extends Error {
  public readonly ok = false;
  public readonly isRequestError = true;
  static {
    this.prototype.name = "RequestError";
  }
  constructor(
    public readonly statusCode: number,
    public readonly responseBody: string,
    public readonly responseHeaders: Headers,
  ) {
    super(`Request failed with status code ${statusCode}: ${responseBody}`);
  }
}

export class ParseResponseError extends Error {
  public readonly ok = false;
  public readonly isParseResponseError = true;
  static {
    this.prototype.name = "ParseResponseError";
  }
  constructor(
    public readonly statusCode: number,
    public readonly data: unknown,
    public readonly parseError: z.ZodError,
    public readonly responseHeaders: Headers,
  ) {
    super(
      `Failed to parse response with status code ${statusCode}: ${JSON.stringify(
        data,
      )}`,
    );
  }
}

export function createClient({
  serviceDomain,
  apiKey,
  requestBaseOptions,
}: {
  serviceDomain: string;
  apiKey: string;
  requestBaseOptions?: RequestOptions;
}) {
  const headers = {
    "Content-Type": "application/json",
    "X-MICROCMS-API-KEY": apiKey,
  };

  function contentUrl(path: string) {
    return new URL(
      path,
      `https://${serviceDomain}.microcms.io/api/v1/`,
    ).toString();
  }
  function managementUrl(path: string) {
    return new URL(
      path,
      `https://${serviceDomain}.microcms-management.io/api/v1/`,
    ).toString();
  }

  async function request<OkResponseSchema extends z.AnyZodObject>(
    url: string,
    okResponseSchema: OkResponseSchema,
    options: RequestOptions,
  ): Promise<
    | {
        ok: true;
        statusCode: number;
        data: z.infer<OkResponseSchema>;
        responseHeaders: Headers;
      }
    | RequestError
    | ParseResponseError
  > {
    const opts = {
      ...requestBaseOptions,
      ...options,
      headers: {
        ...headers,
        ...(requestBaseOptions?.headers ?? {}),
        ...(options?.headers ?? {}),
      },
    };

    const res = await (opts.customFetcher ?? fetch)(url, opts);
    if (!res.ok) {
      return new RequestError(res.status, await res.text(), res.headers);
    }

    let respBody: unknown;
    if (res.status === 202) {
      await res.text();
      respBody = {};
    } else {
      respBody = await res.json();
    }
    const parser = okResponseSchema.safeParse(respBody);
    if (!parser.success) {
      return new ParseResponseError(
        res.status,
        respBody,
        parser.error,
        res.headers,
      );
    }
    return {
      ok: true,
      statusCode: res.status,
      data: parser.data,
      responseHeaders: res.headers,
    };
  }

  function requestGet<OkResponseSchema extends z.AnyZodObject>(
    url: string,
    okResponseSchema: OkResponseSchema,
    query?: QueryForObjectApi | QueryForListApi,
    options?: RequestOptions,
  ): Promise<
    | {
        ok: true;
        statusCode: number;
        data: z.infer<OkResponseSchema>;
        responseHeaders: Headers;
      }
    | RequestError
    | ParseResponseError
  > {
    const searchParams = new URLSearchParams(
      Object.fromEntries(
        Object.entries(query ?? {}).map(([k, v]) => [
          k,
          Array.isArray(v) ? v.join(",") : v.toString(),
        ]),
      ),
    );

    return request(
      url + (searchParams.size > 0 ? `?${searchParams.toString()}` : ""),
      okResponseSchema,
      { ...options, method: "GET" },
    );
  }

  function requestWrite<OkResponseSchema extends z.AnyZodObject>(
    method: "POST" | "PUT" | "PATCH" | "DELETE",
    url: string,
    okResponseSchema: OkResponseSchema,
    content?: unknown,
    options?: RequestOptions,
  ): Promise<
    | {
        ok: true;
        statusCode: number;
        data: z.infer<OkResponseSchema>;
        responseHeaders: Headers;
      }
    | RequestError
    | ParseResponseError
  > {
    return request(url, okResponseSchema, {
      ...options,
      method,
      body: content ? JSON.stringify(content) : null,
    });
  }

  return {
    sampleForListApi: {
      list: ({
        options,
        ...query
      }: QueryForListApi & { options?: RequestOptions }) =>
        requestGet(
          contentUrl(`sample-for-list-api`),
          makeListResponseSchema(SampleForListApiSchema),
          query,
          options,
        ),
      get: ({
        id,
        options,
        ...query
      }: QueryForObjectApi & {
        id: string;
        options?: RequestOptions;
      }) =>
        requestGet(
          contentUrl(`sample-for-list-api/${id}`),
          SampleForListApiSchema.merge(MicroCmsListContentFieldsSchema),
          query,
          options,
        ),
      post: ({
        content,
        status,
        options,
      }: {
        content: SampleForListApiInput;
        status?: "draft";
        options?: RequestOptions;
      }) =>
        requestWrite(
          "POST",
          contentUrl(`sample-for-list-api${status ? `?status=${status}` : ""}`),
          OnlyIdSchema,
          content,
          options,
        ),
      put: ({
        id,
        content,
        status,
        options,
      }: {
        id: string;
        content: SampleForListApiInput;
        status?: "draft";
        options?: RequestOptions;
      }) =>
        requestWrite(
          "PUT",
          contentUrl(
            `sample-for-list-api/${id}${status ? `?status=${status}` : ""}`,
          ),
          OnlyIdSchema,
          content,
          options,
        ),
      patch: ({
        id,
        content,
        options,
      }: {
        id: string;
        content: Partial<SampleForListApiInput>;
        options?: RequestOptions;
      }) =>
        requestWrite(
          "PATCH",
          contentUrl(`sample-for-list-api/${id}`),
          OnlyIdSchema,
          content,
          options,
        ),
      delete: ({ id, options }: { id: string; options?: RequestOptions }) =>
        requestWrite(
          "DELETE",
          contentUrl(`sample-for-list-api/${id}`),
          z.object({}),
          undefined,
          options,
        ),
      listMetadata: ({
        options,
        ...query
      }: Pick<QueryForListApi, "limit" | "offset"> & {
        options?: RequestOptions;
      }) =>
        requestGet(
          managementUrl(`contents/sample-for-list-api`),
          makeListResponseSchema(ListContentMetadataSchema),
          query,
          options,
        ),
      getMetadata: ({
        id,
        options,
      }: QueryForObjectApi & {
        id: string;
        options?: RequestOptions;
      }) =>
        requestGet(
          managementUrl(`contents/sample-for-list-api/${id}`),
          ListContentMetadataSchema,
          undefined,
          options,
        ),
      patchStatus: ({
        id,
        status,
        options,
      }: {
        id: string;
        status: "PUBLISH" | "DRAFT";
        options?: RequestOptions;
      }) =>
        requestWrite(
          "PATCH",
          managementUrl(`contents/sample-for-list-api/${id}/status`),
          OnlyIdSchema,
          { status: [status] },
          options,
        ),
    },
    sampleForObjectApi: {
      get: (
        param?: QueryForObjectApi & {
          options?: RequestOptions;
        },
      ) => {
        const { options, ...query } = param ?? {};
        return requestGet(
          contentUrl(`sample-for-object-api`),
          SampleForObjectApiSchema.merge(MicroCmsObjectContentFieldsSchema),
          query,
          options,
        );
      },
      patch: ({
        content,
        options,
      }: {
        content: Partial<SampleForObjectApiInput>;
        options?: RequestOptions;
      }) =>
        requestWrite(
          "PATCH",
          contentUrl(`sample-for-object-api`),
          OnlyIdSchema,
          content,
          options,
        ),
      getMetadata: (params?: { options?: RequestOptions }) => {
        const { options } = params ?? {};
        return requestGet(
          managementUrl(`contents/sample-for-object-api`),
          ObjectContentMetadataSchema,
          undefined,
          options,
        );
      },
    },
  };
}
